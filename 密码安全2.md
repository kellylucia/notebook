第一部分：从零理解“签名”与“验签”
这是考试的核心，也是最大的难点。我们必须先把它攻克。

一、终极比喻：“蜡封信封”

想象一下古代国王送信：

签名（Sign）：国王写完信后，将熔化的蜡油滴在信封口，然后用他的戒指印章（私钥） 在软蜡上压出一个独特的图案。这个过程就是 “签名”。

关键：这个图案只有国王的戒指能压出来，别人无法仿造。

发送：信使将这封盖了章的信（原文+签名） 送出去。

验签（Verify）：将军收到信，看到信封口的蜡封。他拿出国王之前颁发给所有人的戒指图案的拓印（公钥），去对比蜡封上的图案。

如果完全匹配：说明这封信确实是国王发的（身份认证），而且信在途中没有被掉包或篡改（完整性校验）。因为信一旦被改动，蜡封就会碎裂。

如果不匹配：说明信是假的！

二、数字化流程（SM2 + SM3组合拳）

把上面的比喻数字化，就是我们的国密算法实战：

准备阶段：

国王（服务器/用户）生成一对钥匙：私钥（绝密的戒指） 和 公钥（公开的图案拓印）。

实操流程：

对数据取“指纹”（Hash）：

国王要发送的“信”（数据）可能很长，直接用戒指盖印很麻烦。

于是，他先对“信”用SM3算法计算一下，生成一个固定长度、独一无二的摘要（Digest），你可以理解为这封信的 “数字指纹”。

特点：任何一点改动，“指纹”都会彻底改变。

用私钥加密“指纹”（签名）：

国王用自己的SM2私钥，去加密这个“指纹”。

加密后的结果，就是那个独特的 “数字签名”。

他将原始数据和这个数字签名一起发送出去。

接收方验证：

将军收到后，做两件事：

a. 用同样的SM3算法，对收到的原始数据重新计算一次“指纹”。

b. 用国王公开的SM2公钥，去解密收到的那个“数字签名”。如果解密成功，会得到一个“指纹”。

验签核心：对比 a 和 b 两步得到的两个“指纹”。

如果一模一样：验签成功！证明信是国王发的，且没被篡改。

如果不一样：验签失败！信号有问题。

为什么安全？

因为只有私钥能生成这个签名，公钥只能验证它。黑客没有私钥，无法伪造签名；他如果改了数据，新的“指纹”对不上，立刻就会被发现。

第二部分：实战操作 - 看懂、模仿、会用
光说不练假把式。我们现在就来模拟一下实际操作。虽然你未必现在就有环境，但一定要看懂这个流程。

场景： 用一个虚拟的“密码机”或“加密卡”（我们称之为gm_tool）来对一份文件document.txt进行签名和验签。

步骤一：生成SM2密钥对

bash
# 使用工具生成一个SM2私钥文件（private_key.pem）
gm_tool gen_private_key -algo SM2 -out private_key.pem

# 从私钥中提取出对应的公钥文件（public_key.pem）
gm_tool extract_public_key -in private_key.pem -out public_key.pem
实操要点：private_key.pem 必须绝对保密！public_key.pem可以发给任何人。

步骤二：计算文件的SM3哈希值（取指纹）

bash
# 计算document.txt的哈希值，并将结果保存到hash.txt
gm_tool hash -algo SM3 -in document.txt -out hash.value
你可以自己验证：用任何支持SM3的校验工具计算document.txt，得到的结果肯定和hash.value里的一模一样。

步骤三：使用私钥进行签名

bash
# 用私钥对刚才计算的哈希值进行签名，得到签名文件signature.sig
gm_tool sign -algo SM2 -key private_key.pem -hash hash.value -out signature.sig
现在，你把document.txt（原始数据）和signature.sig（签名）发给对方。

步骤四：对方使用公钥进行验签

bash
# 对方收到文件后，先用SM3计算收到文件的哈希值
gm_tool hash -algo SM3 -in received_document.txt -out received_hash.value

# 然后，用你的公钥和收到的签名，去验证这个哈希值
gm_tool verify -algo SM2 -key public_key.pem -hash received_hash.value -sig signature.sig

# 工具会返回结果：Verification SUCCESS 或 Verification FAILED
如果成功，说明文件完好无损，且确定是你发的。

如果失败，红灯警报！文件要么不是你的，要么被篡改了。

第三部分：密码产品与接口 - 安全的“保险箱”
知道了原理，我们来看看这些东西在现实中长什么样，怎么用。

一、密码产品（硬件）

USB Key（U盾/电子钥匙）：

是什么：就是你手上那个插电脑上才能转账的U盘。

核心安全原理：你的私钥永远在这个U盘的小芯片里，永远不出来。当你需要签名时，电脑把数据发给U盾，U盾在内部完成签名操作，只把签名结果输出给电脑。病毒就算控制了你的电脑，也偷不走你的私钥。

考试考点：为什么U盾安全？答：私钥不可导出。

服务器密码机：

是什么：银行、政府机房里的“黑盒子”，专门负责高性能、高安全的加解密运算。

干嘛用：处理海量的交易签名、数据加密等。

二、设备接口规范（软件怎么和“保险箱”说话）

不同的硬件厂商生产的U盾，软件怎么才能都通用呢？就需要一套标准的“指令集”。

国际标准：PKCS#11

比喻：一套通用的“保险箱操作手册”。

无论保险箱是哪个牌子，只要它支持这本手册，软件就知道该发送“C_GenerateKey”（生成密钥）、“C_Sign”（签名）等指令来操作它。

国密标准：GMT 0018-2012

比喻：中文写的、专门针对国密算法（SM2/SM3/SM4）优化的“保险箱操作手册”。

我们的国产密码硬件，都会遵循这个规范来提供接口函数（如SDF_ExternalSign_ECC用来做SM2签名）。

考试考点：国密算法对应的接口规范是什么？答：GMT 0018。

**实操联想（写给软件看）：

c
// 软件调用密码Key的简化流程（伪代码）
1. 打开设备（SDF_OpenDevice）；
2. 连接密码Key（SDF_OpenSession）；
3. 登录验证PIN码（SDF_VerifyPIN）；
4. 获取私钥句柄（SDF_GetPrivateKeyAccessRight）；
5. 调用签名函数，传入数据和私钥句柄（SDF_ExternalSign_ECC）；
6. 密码Key在内部计算签名并返回结果；
7. 退出关闭设备。
你不用会写代码，但要知道软件和硬件是这么配合的。

第四部分：终极复习与应试技巧
一、知识体系梳理

主题	核心原理	关键实操	必考答案
签名/验签	私钥签名，公钥验签；SM3取哈希保障完整性	理解“计算哈希->私钥签哈希->公钥验哈希”流程	实现身份认证、不可否认性和完整性校验
SM2 vs SM4	SM2（非对称，密钥对，用于签名/密钥交换）；SM4（对称，单密钥，用于加密数据）	SM4加密大数据，用SM2加密SM4的密钥	分清用途：SM2用于身份相关，SM4用于数据保密
密码产品	硬件存储私钥，私钥永不导出	知道U盾和服务器密码机的用途	U盾安全的原因是私钥不可导出
接口规范	定义软件如何调用密码硬件	记住国密标准号：GMT 0018	国密接口规范是GMT 0018
二、考试怎么考？

选择题/判断题：

“以下哪种算法属于非对称加密？（A. SM2 B. SM4 C. SM3）”

“数字签名能保证数据的机密性。（对/错）”（错！ 签名保证的是身份、完整性和不可否认性，加密才保证机密性）

“国密算法中的杂凑算法是？（SM3）”

简答题：

简述数字签名的过程和目的。

答：过程：1）对数据用SM3计算哈希值；2）用发送方SM2私钥加密哈希值，得到签名。3）将数据和签名一并发送。验证：1）用同样算法计算收到数据的哈希值；2）用发送方公钥解密签名，得到原始哈希值；3）对比两个哈希值，一致则验证成功。

目的：验证数据发送方身份，保证数据完整性，实现操作的不可否认性。

对比SM2和SM4算法的区别。

（按上面表格里的内容回答即可）

实操题（描述题）：

“描述一个使用USB Key完成网上银行转账交易签名验证的流程。”

答：1）用户插入USB Key，输入PIN码登录；2）银行系统将交易信息（金额、收款方）发送给用户电脑；3）电脑将交易信息发送给USB Key；4）USB Key内部使用用户的私钥对交易信息的哈希值进行签名；5）签名结果返回给银行服务器；6）银行使用用户预留的公钥验证签名，验证通过则执行转账。
